<html>
<script src="mp4box.all.js"></script>
<script>
async function reencode(file) {
  const startNow = performance.now();

  let videoDecoder;
  let videoEncoder;

  let videoTrack = null;
  let audioTrack = null;
  let decodedVideoFrameIndex = 0;
  let encodedVideoFrameIndex = 0;
  let videoFrameCount = 0;
  let audioFrameCount = 0;
  let decodedAudioFrameIndex = 0;
  let encodedAudioFrameIndex = 0;
  let nextVideoKeyFrameTimestamp = 0;
  let nextAudioKeyFrameTimestamp = 0;
  let sampleVideoDurations = [];
  let videoTrackID = null;
  let audioTrackID = null;

  const mp4boxOutputFile = MP4Box.createFile();
  const mp4boxInputFile = MP4Box.createFile();
  mp4boxInputFile.onError = error => console.error(error);
  mp4boxInputFile.onReady = async (info) => {
    videoTrack = info.videoTracks[0];
    audioTrack = info.audioTracks[0];

    videoDecoder = new VideoDecoder({
      async output(inputFrame) {
        const bitmap = await createImageBitmap(inputFrame);

        const outputFrame = new VideoFrame(bitmap, {
          timestamp: inputFrame.timestamp,
        });

        const keyFrameEveryHowManySeconds = 2;
        let keyFrame = false;
        if (inputFrame.timestamp >= nextVideoKeyFrameTimestamp) {
          keyFrame = true;
          nextVideoKeyFrameTimestamp = inputFrame.timestamp + keyFrameEveryHowManySeconds * 1e6;
        }
        videoEncoder.encode(outputFrame, { keyFrame });
        inputFrame.close();
        outputFrame.close();

        decodedVideoFrameIndex++;
        displayProgress();
      },
      error(error) {
        console.error(error);
      }
    });

    let description;
    const trak = mp4boxInputFile.getTrackById(videoTrack.id);
    for (const entry of trak.mdia.minf.stbl.stsd.entries) {
      if (entry.avcC || entry.hvcC) {
        const stream = new DataStream(undefined, 0, DataStream.BIG_ENDIAN);
        if (entry.avcC) {
          entry.avcC.write(stream);
        } else {
          entry.hvcC.write(stream);
        }
        description = new Uint8Array(stream.buffer, 8); // Remove the box header.
        break;
      }
    }

    videoDecoder.configure({
      codec: videoTrack.codec,
      codedWidth: videoTrack.track_width,
      codedHeight: videoTrack.track_height,
      hardwareAcceleration: 'prefer-hardware',
      description,
    });

    videoEncoder = new VideoEncoder({
      output(chunk, metadata) {
        let uint8 = new Uint8Array(chunk.byteLength);
        chunk.copyTo(uint8);

        const timescale = 90000;
        if (videoTrackID === null) {
          const description = metadata.decoderConfig.description;
          videoTrackID = mp4boxOutputFile.addTrack({
            width: videoTrack.track_width,
            height: videoTrack.track_height,
            timescale,
            avcDecoderConfigRecord: description,
          });
        }

        const sampleDuration = sampleVideoDurations.shift() / (1_000_000 / timescale);
        mp4boxOutputFile.addSample(videoTrackID, uint8, {
          duration: sampleDuration,
          is_sync: chunk.type === 'key',
        });

        encodedVideoFrameIndex++;
        displayProgress();
      },
      error(error) {
        console.error(error);
      }
    });

    videoEncoder.configure({
      codec: 'avc1.4d0034',
      width: videoTrack.track_width,
      height: videoTrack.track_height,
      hardwareAcceleration: 'prefer-hardware',
      bitrate: 14_000_000,
      alpha: 'discard',
      bitrateMode: 'variable',
      latencyMode: 'realtime',
    });

    mp4boxInputFile.setExtractionOptions(videoTrack.id, null, {nbSamples: Infinity});

    if (audioTrack) {
      audioDecoder = new AudioDecoder({
        async output(audioData) {
          audioEncoder.encode(audioData, { keyFrame: true });
          audioData.close();

          decodedAudioFrameIndex++;
          displayProgress();
        },
        error(error) {
          console.error(error);
        }
      });

      const audioCodec = 'mp4a.40.02';

      audioDecoder.configure({
        codec: audioCodec, //audioTrack.codec,
        numberOfChannels: audioTrack.audio.channel_count,
        sampleRate: audioTrack.audio.sample_rate,
      });

      audioEncoder = new AudioEncoder({
        output(chunk, metadata) {
          let uint8 = new Uint8Array(chunk.byteLength);
          chunk.copyTo(uint8);

          const timescale = 90000;
          if (audioTrackID === null) {
            // audioTrackID = mp4boxOutputFile.addTrack({
            //   type: 'mp4a',
            //   timescale,
            // });
          }

          console.log(encodedAudioFrameIndex, uint8);

          // mp4boxOutputFile.addSample(audioTrackID, uint8, {
          //   duration: chunk.duration / (1_000_000 / timescale),
          //   is_sync: chunk.type === 'key',
          // });

          encodedAudioFrameIndex++;
          displayProgress();
        },
        error(error) {
          console.error(error);
        }
      });


      audioEncoder.configure({
        codec: audioCodec,
        numberOfChannels: audioTrack.audio.channel_count,
        sampleRate: audioTrack.audio.sample_rate,
      });

      mp4boxInputFile.setExtractionOptions(audioTrack.id, null, {nbSamples: Infinity});
    }

    mp4boxInputFile.start();
  };

  function displayProgress() {
    progress.innerText =
      "Decoding video frame " + decodedVideoFrameIndex + " (" + Math.round(100 * decodedVideoFrameIndex / videoFrameCount) + "%)\n" +
      "Encoding video frame " + encodedVideoFrameIndex + " (" + Math.round(100 * encodedVideoFrameIndex / videoFrameCount) + "%)\n";
    if (audioTrack) {
      progress.innerText +=
        "Decoding audio frame " + decodedAudioFrameIndex + " (" + Math.round(100 * decodedAudioFrameIndex / audioFrameCount) + "%)\n" +
        "Encoding audio frame " + encodedAudioFrameIndex + " (" + Math.round(100 * encodedAudioFrameIndex / audioFrameCount) + "%)\n";
    }
  }

  mp4boxInputFile.onSamples = function(track_id, ref, samples) {
    for (const sample of samples) {
      const chunk = {
        type: sample.is_sync ? "key" : "delta",
        timestamp: sample.cts * 1_000_000 / sample.timescale,
        duration: sample.duration * 1_000_000 / sample.timescale,
        data: sample.data
      };
      if (track_id === videoTrack.id) {
        videoFrameCount++;
        sampleVideoDurations.push(sample.duration * 1_000_000 / sample.timescale);
        videoDecoder.decode(new EncodedVideoChunk(chunk));
      } else {
        audioFrameCount++;
        audioDecoder.decode(new EncodedAudioChunk(chunk));
      }
    }
    if (track_id !== videoTrack.id) {
      console.log('Number of audio frames:', audioFrameCount);
    }
  }

  async function onComplete() {
    mp4boxOutputFile.save("mp4box.mp4");

    const seconds = (performance.now() - startNow) / 1000;
    progress.innerText =
      "Re-encoded " + encodedVideoFrameIndex + " video frames in " + (Math.round(seconds * 100) / 100) + "s at " +
      Math.round(encodedVideoFrameIndex / seconds) + " fps\n";
    if (audioTrack) {
      progress.innerText +=
        "Re-encoded audio " + encodedAudioFrameIndex + " video frames in " + (Math.round(seconds * 100) / 100) + "s at " +
        Math.round(encodedAudioFrameIndex / seconds) + " fps";
    }
  };

  var reader = new FileReader();
  reader.onload = async function() {
    this.result.fileStart = 0;
    mp4boxInputFile.appendBuffer(this.result);
    mp4boxInputFile.flush();

    if (audioTrack) {
      await audioDecoder.flush();
      audioDecoder.close();
    }
    await videoDecoder.flush();
    videoDecoder.close();

    if (audioTrack) {
      await audioEncoder.flush();
      audioEncoder.close();
    }
    await videoEncoder.flush();
    videoEncoder.close();

    onComplete();
  };
  reader.readAsArrayBuffer(file);
}
</script>

<p>
  Select a video to re-encode:
  <input type="file" onchange="reencode(event.target.files[0])"></input>
  <div id="progress"></div>
</p>
